<!DOCTYPE html>
<html>
<head>
    <title>Drone Voxel - Yağ Gibi Akış</title>
    <meta charset="UTF-8">
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { width: 100%; height: 100vh; cursor: crosshair; }
        #ui {
            position: absolute; top: 10px; left: 10px;
            color: #0f0; font-family: monospace; font-size: 16px; font-weight: bold;
            text-shadow: 1px 1px 0 #000; pointer-events: none;
        }
        #center-marker {
            position: absolute; top: 50%; left: 50%; width: 40px; height: 40px;
            transform: translate(-50%, -50%);
            border: 2px solid rgba(255, 255, 255, 0.3); border-radius: 50%;
            pointer-events: none;
            transition: border-color 0.2s;
        }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-family: sans-serif; background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px;
        }
    </style>
</head>
<body>
    <div id="ui">
        MOD: [P] | GAZ: [W] | YÖN: Mouse<br>
        DURUM: Stabilize Uçuş (Süspansiyon Aktif)
    </div>
    <div id="center-marker"></div>
    <div id="loading">SİSTEM BAŞLATILIYOR...</div>
    <canvas id="screen"></canvas>

<script>
const canvas = document.getElementById('screen');
const ctx = canvas.getContext('2d');

const screenWidth = 400; 
const screenHeight = 300;
canvas.width = screenWidth;
canvas.height = screenHeight;

let mapSize = 1024;
let colorData = null;
let heightData = null;
let loaded = false;
let cameraMode = 3; 

let drone = {
    x: 512, y: 512, 
    height: 150, 
    angle: 0, 
    horizon: 120, 
    speed: 0
};

function loadMaps() {
    const imgColor = new Image();
    const imgHeight = new Image();
    imgColor.crossOrigin = "Anonymous";
    imgHeight.crossOrigin = "Anonymous";

    let imagesLoaded = 0;
    function onImageLoad() {
        imagesLoaded++;
        if (imagesLoaded === 2) {
            const tCanvas = document.createElement('canvas');
            tCanvas.width = mapSize; tCanvas.height = mapSize;
            const tCtx = tCanvas.getContext('2d');

            tCtx.drawImage(imgColor, 0, 0);
            colorData = tCtx.getImageData(0, 0, mapSize, mapSize).data;

            tCtx.drawImage(imgHeight, 0, 0);
            heightData = tCtx.getImageData(0, 0, mapSize, mapSize).data;

            loaded = true;
            document.getElementById('loading').style.display = 'none';
            gameLoop();
        }
    }

    imgColor.src = 'color.png'; 
    imgHeight.src = 'height.png';
    imgColor.onload = onImageLoad;
    imgHeight.onload = onImageLoad;
}

let input = { forward: false };

window.onkeydown = (e) => {
    if(e.key === 'w' || e.key === 'W') input.forward = true;
    if(e.key === 'p' || e.key === 'P') { cameraMode++; if(cameraMode > 3) cameraMode = 1; }
};
window.onkeyup = (e) => { if(e.key === 'w' || e.key === 'W') input.forward = false; };

window.onmousemove = (e) => {
    let xRatio = (e.clientX / window.innerWidth - 0.5); 
    drone.angle += xRatio * 0.1; 

    let yRatio = (e.clientY / window.innerHeight - 0.5);
    // Ölü Bölge (Deadzone) - Mouse ortadaysa kilitler
    if (yRatio > -0.15 && yRatio < 0.15) {
        drone.horizon = 120; 
        document.getElementById('center-marker').style.borderColor = "#0f0"; 
    } else {
        drone.horizon = 120 + (yRatio * 200);
        document.getElementById('center-marker').style.borderColor = "#fff"; 
    }
};

window.onmousedown = () => input.forward = true;
window.onmouseup = () => input.forward = false;

function drawDroneModel() {
    let cx = screenWidth / 2;
    let cy = screenHeight - 60; 
    if (cameraMode === 2) cy = screenHeight - 100;

    ctx.fillStyle = "#333"; ctx.fillRect(cx - 20, cy, 40, 10);
    
    ctx.strokeStyle = "#555"; ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(cx - 20, cy + 5); ctx.lineTo(cx - 40, cy - 10);
    ctx.moveTo(cx + 20, cy + 5); ctx.lineTo(cx + 40, cy - 10); 
    ctx.moveTo(cx - 20, cy + 5); ctx.lineTo(cx - 40, cy + 20); 
    ctx.moveTo(cx + 20, cy + 5); ctx.lineTo(cx + 40, cy + 20); 
    ctx.stroke();

    ctx.fillStyle = "rgba(200, 255, 255, 0.5)";
    let r = 14; 
    // Pervaneler dönerken hafif bulanıklaşsın
    ctx.beginPath(); ctx.arc(cx - 40, cy - 10, r, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(cx + 40, cy - 10, r, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(cx - 40, cy + 20, r, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(cx + 40, cy + 20, r, 0, Math.PI*2); ctx.fill();
    
    ctx.fillStyle = input.forward ? "#0f0" : "#f00"; 
    ctx.fillRect(cx - 5, cy + 2, 10, 6);
}

function gameLoop() {
    if (!loaded) return;

    if (input.forward) drone.speed = 3; else drone.speed *= 0.92;
    
    drone.x += Math.cos(drone.angle) * drone.speed;
    drone.y += Math.sin(drone.angle) * drone.speed;

    // --- YENİ YÜKSEKLİK MANTIĞI (SÜSPANSİYON) ---
    let mapIndex = ((Math.floor(drone.y) & (mapSize-1)) * mapSize + (Math.floor(drone.x) & (mapSize-1))) * 4;
    let groundHeight = heightData[mapIndex];
    
    // Hedef yükseklik: Zeminin 120 birim üstü
    let targetHeight = groundHeight + 120;
    
    // ANINDA ORAYA GİTME! Yavaş yavaş git (Smoothing)
    // 0.05 değeri süspansiyon yumuşaklığıdır. (Küçükse daha yumuşak)
    drone.height += (targetHeight - drone.height) * 0.05;

    // --- Çizim ve Kamera ---
    let renderX = drone.x;
    let renderY = drone.y;
    let renderHeight = drone.height;

    if (cameraMode === 2) { 
        renderX -= Math.cos(drone.angle) * 300;
        renderY -= Math.sin(drone.angle) * 300;
        renderHeight += 200;
    } 
    else if (cameraMode === 3) { 
        renderX -= Math.cos(drone.angle) * 100;
        renderY -= Math.sin(drone.angle) * 100;
        renderHeight += 50;
    }

    let imgData = ctx.createImageData(screenWidth, screenHeight);
    let buf = new Uint32Array(imgData.data.buffer);
    buf.fill(0xFFFFCC66); 

    let sinA = Math.sin(drone.angle);
    let cosA = Math.cos(drone.angle);
    let viewDist = 1000; 

    for (let i = 0; i < screenWidth; i++) {
        let deltaX = (cosA * viewDist - sinA * (i - screenWidth/2)) / viewDist;
        let deltaY = (sinA * viewDist + cosA * (i - screenWidth/2)) / viewDist;
        
        let posX = renderX; 
        let posY = renderY;
        let maxH = screenHeight;

        for (let z = 1; z < viewDist; z += 2) {
            posX += deltaX * 2;
            posY += deltaY * 2;
            
            let mX = Math.floor(posX) & (mapSize - 1);
            let mY = Math.floor(posY) & (mapSize - 1);
            let offset = (mY * mapSize + mX) * 4;
            let h = heightData[offset];
            let hOnScreen = (renderHeight - h) / z * 120 + drone.horizon;

            if (hOnScreen < maxH) {
                let r = colorData[offset];
                let g = colorData[offset+1];
                let b = colorData[offset+2];
                let color = (255 << 24) | (b << 16) | (g << 8) | r;

                for (let y = Math.max(0, hOnScreen|0); y < maxH; y++) {
                    buf[y * screenWidth + i] = color;
                }
                maxH = hOnScreen;
            }
        }
    }
    ctx.putImageData(imgData, 0, 0);

    if (cameraMode !== 1) drawDroneModel();
    if (cameraMode === 1) {
        ctx.strokeStyle = "rgba(0,255,0,0.5)"; ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(screenWidth/2 - 10, screenHeight/2); ctx.lineTo(screenWidth/2 + 10, screenHeight/2);
        ctx.moveTo(screenWidth/2, screenHeight/2 - 10); ctx.lineTo(screenWidth/2, screenHeight/2 + 10);
        ctx.stroke();
    }
    requestAnimationFrame(gameLoop);
}

loadMaps();
</script>
</body>
</html>
