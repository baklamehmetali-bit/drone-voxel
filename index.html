<!DOCTYPE html>
<html>
<head>
    <title>Drone Voxel - Real FPV</title>
    <meta charset="UTF-8">
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { width: 100%; height: 100vh; cursor: none; }
        #ui {
            position: absolute; top: 10px; left: 10px;
            color: #0f0; font-family: monospace; font-size: 16px; font-weight: bold;
            text-shadow: 1px 1px 0 #000; pointer-events: none;
        }
        #center-marker {
            position: absolute; top: 50%; left: 50%; width: 40px; height: 40px;
            transform: translate(-50%, -50%);
            border: 2px solid rgba(255, 255, 255, 0.3); border-radius: 50%;
            pointer-events: none; transition: border-color 0.2s;
        }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-family: sans-serif; background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px;
        }
    </style>
</head>
<body>
    <div id="ui">
        MOD: [P] | GAZ: [W]<br>
        DURUM: FPV Modu (Dünya Dönüyor)
    </div>
    <div id="center-marker"></div>
    <div id="loading">GYROSCOPE CALIBRATING...</div>
    <canvas id="screen"></canvas>

<script>
const canvas = document.getElementById('screen');
const ctx = canvas.getContext('2d');

// Daha geniş bir alan çizip (overscan) döndüreceğiz ki köşeler siyah kalmasın
const screenWidth = 480; 
const screenHeight = 360;
canvas.width = screenWidth;
canvas.height = screenHeight;

let mapSize = 1024;
let colorData = null;
let heightData = null;
let loaded = false;
let cameraMode = 3; 

// --- FİZİK ---
let drone = {
    x: 512, y: 512, 
    height: 150, 
    angle: 0, 
    horizon: 120,    
    speed: 0,
    maxSpeed: 6.0,   // Biraz daha hızlı
    acceleration: 0.2,
    friction: 0.98,  // Daha çok kayma (Drift)
    roll: 0,         
    pitch: 0         
};

function loadMaps() {
    const imgColor = new Image();
    const imgHeight = new Image();
    imgColor.crossOrigin = "Anonymous";
    imgHeight.crossOrigin = "Anonymous";

    let imagesLoaded = 0;
    function onImageLoad() {
        imagesLoaded++;
        if (imagesLoaded === 2) {
            const tCanvas = document.createElement('canvas');
            tCanvas.width = mapSize; tCanvas.height = mapSize;
            const tCtx = tCanvas.getContext('2d');
            tCtx.drawImage(imgColor, 0, 0);
            colorData = tCtx.getImageData(0, 0, mapSize, mapSize).data;
            tCtx.drawImage(imgHeight, 0, 0);
            heightData = tCtx.getImageData(0, 0, mapSize, mapSize).data;
            loaded = true;
            document.getElementById('loading').style.display = 'none';
            gameLoop();
        }
    }
    imgColor.src = 'color.png'; 
    imgHeight.src = 'height.png';
    imgColor.onload = onImageLoad;
    imgHeight.onload = onImageLoad;
}

let input = { forward: false, mouseX: 0, mouseY: 0 };

window.onkeydown = (e) => {
    if(e.key === 'w' || e.key === 'W') input.forward = true;
    if(e.key === 'p' || e.key === 'P') { cameraMode++; if(cameraMode > 3) cameraMode = 1; }
};
window.onkeyup = (e) => { if(e.key === 'w' || e.key === 'W') input.forward = false; };

window.onmousemove = (e) => {
    let xRatio = (e.clientX / window.innerWidth - 0.5); 
    input.mouseX = xRatio; 
    drone.angle += xRatio * 0.08; 

    let yRatio = (e.clientY / window.innerHeight - 0.5);
    input.mouseY = yRatio;
    
    // Orta nokta rengi
    if (yRatio > -0.15 && yRatio < 0.15) {
        document.getElementById('center-marker').style.borderColor = "#0f0"; 
    } else {
        document.getElementById('center-marker').style.borderColor = "#fff"; 
    }
};
window.onmousedown = () => input.forward = true;
window.onmouseup = () => input.forward = false;

// Drone Modelini Çiz (Bu sefer ekrana sabitlenmiş değil, fiziksel hareket ediyor gibi)
function drawDroneModel() {
    let cx = screenWidth / 2;
    let cy = screenHeight - 60; 
    if (cameraMode === 2) cy = screenHeight - 100;

    // FPV Modundaysak (Mod 1) Modeli çizme, sadece HUD
    if (cameraMode === 1) return;

    // Modeli çizmeden önce canvas'ı DÜZELT (Restore etme mantığı)
    // Çünkü dünya dönüyor ama drone'un (3. şahısta) kameraya göre sabit kalması lazım
    // Ancak gerçekçilik için drone da hafif sallanmalı.
    
    // Sway Effect (Sallanma): Drone dönerken hafifçe ters yöne kayar
    let sway = drone.roll * 50; 
    cx -= sway;

    // Perspektif: Hızlanınca uzaklaş
    let fovOffset = drone.speed * 2;

    ctx.fillStyle = "#222"; 
    // Gövdeyi çiz
    ctx.fillRect(cx - 20, cy + fovOffset, 40, 10);
    
    ctx.strokeStyle = "#444"; ctx.lineWidth = 4;
    ctx.beginPath();
    
    // Pitch (Eğilme) Görselleştirmesi
    let pitchVis = drone.pitch * 20;
    
    ctx.moveTo(cx - 20, cy + 5 + fovOffset); ctx.lineTo(cx - 50, cy - 10 - pitchVis + fovOffset); // Sol Ön
    ctx.moveTo(cx + 20, cy + 5 + fovOffset); ctx.lineTo(cx + 50, cy - 10 - pitchVis + fovOffset); // Sağ Ön
    ctx.moveTo(cx - 20, cy + 5 + fovOffset); ctx.lineTo(cx - 50, cy + 20 + pitchVis + fovOffset); // Sol Arka
    ctx.moveTo(cx + 20, cy + 5 + fovOffset); ctx.lineTo(cx + 50, cy + 20 + pitchVis + fovOffset); // Sağ Arka
    ctx.stroke();

    ctx.fillStyle = "rgba(200, 255, 255, 0.3)";
    let r = 18; 
    ctx.beginPath(); ctx.arc(cx - 50, cy - 10 - pitchVis + fovOffset, r, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(cx + 50, cy - 10 - pitchVis + fovOffset, r, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(cx - 50, cy + 20 + pitchVis + fovOffset, r, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(cx + 50, cy + 20 + pitchVis + fovOffset, r, 0, Math.PI*2); ctx.fill();
    
    // Işık
    ctx.fillStyle = input.forward ? "#0f0" : "#f00"; 
    ctx.fillRect(cx - 6, cy + 2 + fovOffset, 12, 6);
}

function gameLoop() {
    if (!loaded) return;

    // --- FİZİK HESAPLAMALARI ---
    let targetPitch = 0;
    if (input.forward) {
        if (drone.speed < drone.maxSpeed) drone.speed += drone.acceleration;
        targetPitch = 0.6; // Hızlanırken öne eğil
    } else {
        drone.speed *= drone.friction;
        targetPitch = -0.1; // Dururken hafif arkaya
    }
    
    drone.pitch += (targetPitch - drone.pitch) * 0.1;
    
    // Roll (Yatış) - Mouse hareketine göre
    let targetRoll = input.mouseX * 1.0; 
    drone.roll += (targetRoll - drone.roll) * 0.1;

    drone.x += Math.cos(drone.angle) * drone.speed;
    drone.y += Math.sin(drone.angle) * drone.speed;

    // Zemin Takibi (Süspansiyon)
    let mapIndex = ((Math.floor(drone.y) & (mapSize-1)) * mapSize + (Math.floor(drone.x) & (mapSize-1))) * 4;
    let groundHeight = heightData[mapIndex];
    drone.height += ((groundHeight + 120) - drone.height) * 0.1;

    // Kamera Pitch + Manuel Bakış
    let manualLook = 0;
    if (input.mouseY < -0.15 || input.mouseY > 0.15) manualLook = input.mouseY * 250;
    let targetHorizon = 120 + manualLook + (drone.pitch * 120);
    drone.horizon += (targetHorizon - drone.horizon) * 0.1;

    // --- EKRANI TEMİZLE ---
    ctx.clearRect(0,0,screenWidth, screenHeight);
    
    // Arka plan rengi (Gökyüzü)
    ctx.fillStyle = "#87CEEB";
    ctx.fillRect(0,0,screenWidth, screenHeight);

    // --- KAMERA EFEKTİ: DÜNYAYI DÖNDÜRME ---
    // Burası en önemli kısım: Canvas'ın merkezine git, döndür, geri gel.
    ctx.save();
    ctx.translate(screenWidth/2, screenHeight/2);
    
    // ROLL EFEKTİ: Drone sağa yatarsa, dünya sola döner (-drone.roll)
    ctx.rotate(-drone.roll);
    
    ctx.translate(-screenWidth/2, -screenHeight/2);

    // --- VOXEL RENDERING (Dönen Dünyaya Çizim) ---
    // Kamera Pozisyonu Ayarı
    let renderX = drone.x;
    let renderY = drone.y;
    let renderHeight = drone.height;

    // 3. Şahıs için kamerayı geri çekme
    if (cameraMode === 2) { 
        renderX -= Math.cos(drone.angle) * 300;
        renderY -= Math.sin(drone.angle) * 300;
        renderHeight += 200;
    } 
    else if (cameraMode === 3) { 
        renderX -= Math.cos(drone.angle) * 80;
        renderY -= Math.sin(drone.angle) * 80;
        renderHeight += 40;
    }

    let imgData = ctx.createImageData(screenWidth, screenHeight);
    let buf = new Uint32Array(imgData.data.buffer);
    
    // Buffer'ı temizlemiyoruz çünkü rotate işlemi maskeleme yapacak.
    // Ancak getImageData/putImageData döndürmeden etkilenmez.
    // Bu yüzden Voxel motoru için "rotate" hilesi işe yaramaz.
    // ÇÜNKÜ: putImageData rotation'ı yok sayar.
    
    // ÇÖZÜM: Voxel'i çizip sonra onu döndüremeyiz.
    // Canvas'ı döndürdük, ama putImageData pikselleri düz basar.
    // Bu yüzden Voxel çizimini yapıp, onu bir "Görüntü" gibi çizmeliyiz? Hayır çok yavaş olur.
    // EN İYİ HİLE: "Horizon" kayması ile Roll efekti vermek (Eski uçak oyunları gibi).
    
    // Maalesef HTML5 Canvas'ta piksel manipülasyonu (Voxel) ile Rotation (Canvas) uyumsuzdur.
    // Bu yüzden "ROLL" efektini Horizon kaydırarak simüle edeceğiz.
    
    let sinA = Math.sin(drone.angle);
    let cosA = Math.cos(drone.angle);
    let viewDist = 800; 

    // EKRAN TARAMA (Sütun sütun çizim)
    for (let i = 0; i < screenWidth; i++) {
        // ROLL HİLESİ: Sola yatınca, sol sütunların horizonu yukarı, sağınki aşağı iner.
        // Bu, görüntünün eğildiği hissini verir.
        let rollOffset = (i - screenWidth/2) * drone.roll; 
        
        let deltaX = (cosA * viewDist - sinA * (i - screenWidth/2)) / viewDist;
        let deltaY = (sinA * viewDist + cosA * (i - screenWidth/2)) / viewDist;
        
        let posX = renderX; 
        let posY = renderY;
        let maxH = screenHeight; // Aşağıdan yukarı boyama sınırı

        for (let z = 1; z < viewDist; z += 2) {
            posX += deltaX * 2;
            posY += deltaY * 2;
            
            let mX = Math.floor(posX) & (mapSize - 1);
            let mY = Math.floor(posY) & (mapSize - 1);
            let offset = (mY * mapSize + mX) * 4;
            let h = heightData[offset];
            
            // Horizon + Roll Offset
            let hOnScreen = (renderHeight - h) / z * 120 + drone.horizon + rollOffset;

            if (hOnScreen < maxH) {
                let r = colorData[offset];
                let g = colorData[offset+1];
                let b = colorData[offset+2];
                let color = (255 << 24) | (b << 16) | (g << 8) | r;

                for (let y = Math.max(0, hOnScreen|0); y < maxH; y++) {
                    buf[y * screenWidth + i] = color;
                }
                maxH = hOnScreen;
            }
        }
    }
    
    // Pikselleri ekrana bas (Döndürme işlemi iptal oldu çünkü putImageData desteklemez)
    ctx.restore(); // Rotate işlemini geri al (Kullanmadık ama temizlik için)
    ctx.putImageData(imgData, 0, 0);

    // --- HUD ve MODELİ ÇİZME ---
    // Şimdi Canvas özelliklerini kullanarak arayüzü çizebiliriz.
    
    // FPV İçin Yapay Ufuk (Horizon Line)
    if (cameraMode === 1) {
        ctx.save();
        ctx.translate(screenWidth/2, screenHeight/2 + (drone.pitch * 50));
        ctx.rotate(drone.roll); // Çizgiyi döndür
        
        ctx.strokeStyle = "rgba(0, 255, 0, 0.7)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        // Uzun ufuk çizgisi
        ctx.moveTo(-100, 0); ctx.lineTo(-30, 0);
        ctx.moveTo(30, 0); ctx.lineTo(100, 0);
        // Ortadaki nişangah
        ctx.stroke();
        
        ctx.beginPath();
        ctx.arc(0,0, 5, 0, Math.PI*2);
        ctx.stroke();
        
        ctx.restore();
    } else {
        drawDroneModel();
    }

    requestAnimationFrame(gameLoop);
}

loadMaps();
</script>
</body>
</html>
