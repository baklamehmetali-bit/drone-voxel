<!DOCTYPE html>
<html>
<head>
    <title>Drone Voxel - Gerçekçi Tilt</title>
    <meta charset="UTF-8">
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { width: 100%; height: 100vh; cursor: crosshair; }
        #ui {
            position: absolute; top: 10px; left: 10px;
            color: #0f0; font-family: monospace; font-size: 16px; font-weight: bold;
            text-shadow: 1px 1px 0 #000; pointer-events: none;
        }
        #center-marker {
            position: absolute; top: 50%; left: 50%; width: 40px; height: 40px;
            transform: translate(-50%, -50%);
            border: 2px solid rgba(255, 255, 255, 0.3); border-radius: 50%;
            pointer-events: none; transition: border-color 0.2s;
        }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-family: sans-serif; background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px;
        }
    </style>
</head>
<body>
    <div id="ui">
        MOD: [P] | GAZ: [W]<br>
        DURUM: Burun Eğme (Pitch) Aktif
    </div>
    <div id="center-marker"></div>
    <div id="loading">SİSTEM BAŞLATILIYOR...</div>
    <canvas id="screen"></canvas>

<script>
const canvas = document.getElementById('screen');
const ctx = canvas.getContext('2d');

const screenWidth = 400; 
const screenHeight = 300;
canvas.width = screenWidth;
canvas.height = screenHeight;

let mapSize = 1024;
let colorData = null;
let heightData = null;
let loaded = false;
let cameraMode = 3; 

// --- FİZİK DEĞİŞKENLERİ ---
let drone = {
    x: 512, y: 512, 
    height: 150, 
    angle: 0, 
    horizon: 120,    // Temel bakış açısı
    speed: 0,
    maxSpeed: 5.0,
    acceleration: 0.15,
    friction: 0.96,
    roll: 0,         // Sağa/Sola yatış
    pitch: 0         // YENİ: Öne/Arkaya yatış açısı
};

function loadMaps() {
    const imgColor = new Image();
    const imgHeight = new Image();
    imgColor.crossOrigin = "Anonymous";
    imgHeight.crossOrigin = "Anonymous";

    let imagesLoaded = 0;
    function onImageLoad() {
        imagesLoaded++;
        if (imagesLoaded === 2) {
            const tCanvas = document.createElement('canvas');
            tCanvas.width = mapSize; tCanvas.height = mapSize;
            const tCtx = tCanvas.getContext('2d');
            tCtx.drawImage(imgColor, 0, 0);
            colorData = tCtx.getImageData(0, 0, mapSize, mapSize).data;
            tCtx.drawImage(imgHeight, 0, 0);
            heightData = tCtx.getImageData(0, 0, mapSize, mapSize).data;
            loaded = true;
            document.getElementById('loading').style.display = 'none';
            gameLoop();
        }
    }
    imgColor.src = 'color.png'; 
    imgHeight.src = 'height.png';
    imgColor.onload = onImageLoad;
    imgHeight.onload = onImageLoad;
}

let input = { forward: false, mouseX: 0, mouseY: 0 };

window.onkeydown = (e) => {
    if(e.key === 'w' || e.key === 'W') input.forward = true;
    if(e.key === 'p' || e.key === 'P') { cameraMode++; if(cameraMode > 3) cameraMode = 1; }
};
window.onkeyup = (e) => { if(e.key === 'w' || e.key === 'W') input.forward = false; };

window.onmousemove = (e) => {
    let xRatio = (e.clientX / window.innerWidth - 0.5); 
    input.mouseX = xRatio; 
    drone.angle += xRatio * 0.08; 

    let yRatio = (e.clientY / window.innerHeight - 0.5);
    input.mouseY = yRatio; // Mouse dikey konumunu kaydet
    
    // Mouse ile bakış (Manuel)
    if (yRatio > -0.15 && yRatio < 0.15) {
        document.getElementById('center-marker').style.borderColor = "#0f0"; 
    } else {
        document.getElementById('center-marker').style.borderColor = "#fff"; 
    }
};
window.onmousedown = () => input.forward = true;
window.onmouseup = () => input.forward = false;

function drawDroneModel() {
    let cx = screenWidth / 2;
    let cy = screenHeight - 60; 
    if (cameraMode === 2) cy = screenHeight - 100;

    ctx.save();
    
    // 1. ROLL (Sağa Sola Yatış)
    ctx.translate(cx, cy);
    ctx.rotate(drone.roll);
    ctx.translate(-cx, -cy);

    // 2. PITCH (Öne Eğilme - Çizim Hilesi)
    // Pitch değeri arttıkça ön taraf aşağı, arka taraf yukarı kayacak.
    let pitchOffset = drone.pitch * 20; // Eğilme şiddeti

    // Gövde (Hafif basıklaşır)
    ctx.fillStyle = "#222"; 
    ctx.fillRect(cx - 20, cy - (pitchOffset/2), 40, 10);
    
    ctx.strokeStyle = "#444"; ctx.lineWidth = 4;
    ctx.beginPath();
    
    // Arka Kollar (Pitch pozitifse yukarı kalkar)
    let backY = cy - 10 - pitchOffset;
    // Ön Kollar (Pitch pozitifse aşağı iner)
    let frontY = cy + 20 + pitchOffset;

    // Sol Ön
    ctx.moveTo(cx - 20, cy + 5); ctx.lineTo(cx - 45, frontY);
    // Sağ Ön
    ctx.moveTo(cx + 20, cy + 5); ctx.lineTo(cx + 45, frontY); 
    // Sol Arka
    ctx.moveTo(cx - 20, cy + 5); ctx.lineTo(cx - 45, backY); 
    // Sağ Arka
    ctx.moveTo(cx + 20, cy + 5); ctx.lineTo(cx + 45, backY); 
    ctx.stroke();

    // Pervaneler (Ön ve Arka ayrı çizilir)
    ctx.fillStyle = "rgba(200, 255, 255, 0.4)";
    let r = 16; 
    
    // Arka Pervaneler
    ctx.beginPath(); ctx.arc(cx - 45, backY, r, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(cx + 45, backY, r, 0, Math.PI*2); ctx.fill();
    
    // Ön Pervaneler
    ctx.beginPath(); ctx.arc(cx - 45, frontY, r, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(cx + 45, frontY, r, 0, Math.PI*2); ctx.fill();
    
    // Işık
    ctx.fillStyle = input.forward ? "#0f0" : "#f00"; 
    ctx.shadowBlur = 10; ctx.shadowColor = ctx.fillStyle;
    ctx.fillRect(cx - 6, cy + 2 - (pitchOffset/2), 12, 6);
    ctx.shadowBlur = 0;

    ctx.restore();
}

function gameLoop() {
    if (!loaded) return;

    // --- HIZ VE PITCH HESAPLAMA ---
    
    let targetPitch = 0;

    if (input.forward) {
        // Hızlanma
        if (drone.speed < drone.maxSpeed) drone.speed += drone.acceleration;
        targetPitch = 0.5; // Gaz verince öne eğil (Değer 0.5)
    } else {
        // Yavaşlama
        drone.speed *= drone.friction;
        targetPitch = -0.2; // Fren yaparken hafif arkaya yaslan
    }
    
    // Pitch (Eğilme) geçişini yumuşat
    drone.pitch += (targetPitch - drone.pitch) * 0.1;

    // Roll (Yatış) hesapla
    let targetRoll = input.mouseX * 0.8; 
    drone.roll += (targetRoll - drone.roll) * 0.1;

    drone.x += Math.cos(drone.angle) * drone.speed;
    drone.y += Math.sin(drone.angle) * drone.speed;

    // Zemin Takibi
    let mapIndex = ((Math.floor(drone.y) & (mapSize-1)) * mapSize + (Math.floor(drone.x) & (mapSize-1))) * 4;
    let groundHeight = heightData[mapIndex];
    drone.height += ((groundHeight + 120) - drone.height) * 0.05;

    // --- KAMERA EFEKTLERİ ---
    
    // Mouse ile Manuel Bakış
    let manualLook = 0;
    if (input.mouseY < -0.15 || input.mouseY > 0.15) {
        manualLook = input.mouseY * 200;
    }
    
    // Pitch Etkisi: Drone öne eğilince kamera da aşağı bakar (+Pitch)
    // Pitch değeri ile ufuk çizgisini (horizon) kaydırıyoruz.
    let pitchEffect = drone.pitch * 100;

    // Hedef Horizon hesapla
    let targetHorizon = 120 + manualLook + pitchEffect;
    
    // Kamerayı yumuşakça hedefe götür
    drone.horizon += (targetHorizon - drone.horizon) * 0.1;


    // --- RENDERING ---
    let renderX = drone.x;
    let renderY = drone.y;
    let renderHeight = drone.height;

    if (cameraMode === 2) { 
        renderX -= Math.cos(drone.angle) * 300;
        renderY -= Math.sin(drone.angle) * 300;
        renderHeight += 200;
    } 
    else if (cameraMode === 3) { 
        renderX -= Math.cos(drone.angle) * 100;
        renderY -= Math.sin(drone.angle) * 100;
        renderHeight += 50;
    }

    let imgData = ctx.createImageData(screenWidth, screenHeight);
    let buf = new Uint32Array(imgData.data.buffer);
    buf.fill(0xFFFFCC66); 

    let sinA = Math.sin(drone.angle);
    let cosA = Math.cos(drone.angle);
    let viewDist = 1000; 

    for (let i = 0; i < screenWidth; i++) {
        let deltaX = (cosA * viewDist - sinA * (i - screenWidth/2)) / viewDist;
        let deltaY = (sinA * viewDist + cosA * (i - screenWidth/2)) / viewDist;
        
        let posX = renderX; 
        let posY = renderY;
        let maxH = screenHeight;

        for (let z = 1; z < viewDist; z += 2) {
            posX += deltaX * 2;
            posY += deltaY * 2;
            
            let mX = Math.floor(posX) & (mapSize - 1);
            let mY = Math.floor(posY) & (mapSize - 1);
            let offset = (mY * mapSize + mX) * 4;
            let h = heightData[offset];
            let hOnScreen = (renderHeight - h) / z * 120 + drone.horizon;

            if (hOnScreen < maxH) {
                let r = colorData[offset];
                let g = colorData[offset+1];
                let b = colorData[offset+2];
                let color = (255 << 24) | (b << 16) | (g << 8) | r;

                for (let y = Math.max(0, hOnScreen|0); y < maxH; y++) {
                    buf[y * screenWidth + i] = color;
                }
                maxH = hOnScreen;
            }
        }
    }
    ctx.putImageData(imgData, 0, 0);

    if (cameraMode !== 1) drawDroneModel();
    if (cameraMode === 1) {
        // Kokpit - Yapay Ufuk
        ctx.strokeStyle = "rgba(0,255,0,0.5)"; ctx.lineWidth = 2;
        ctx.save();
        ctx.translate(screenWidth/2, screenHeight/2 + (drone.pitch * 50)); // Kokpit de eğilir
        ctx.rotate(drone.roll);
        ctx.beginPath();
        ctx.moveTo(-20, 0); ctx.lineTo(20, 0);
        ctx.moveTo(0, -10); ctx.lineTo(0, 10);
        ctx.stroke();
        ctx.restore();
    }
    requestAnimationFrame(gameLoop);
}

loadMaps();
</script>
</body>
</html>
